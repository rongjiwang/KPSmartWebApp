{
  "_args": [
    [
      {
        "raw": "pg-native@*",
        "scope": null,
        "escapedName": "pg-native",
        "name": "pg-native",
        "rawSpec": "*",
        "spec": "*",
        "type": "range"
      },
      "/Users/cameronmclachlan/WebstormProjects/OtherKPS/PostalSystem"
    ]
  ],
  "_from": "pg-native@*",
  "_id": "pg-native@1.10.1",
  "_inCache": true,
  "_location": "/pg-native",
  "_nodeVersion": "6.10.1",
  "_npmOperationalInternal": {
    "host": "packages-18-east.internal.npmjs.com",
    "tmp": "tmp/pg-native-1.10.1.tgz_1491404030746_0.959228094201535"
  },
  "_npmUser": {
    "name": "brianc",
    "email": "brian.m.carlson@gmail.com"
  },
  "_npmVersion": "3.10.10",
  "_phantomChildren": {
    "core-util-is": "1.0.2",
    "inherits": "2.0.1",
    "isarray": "0.0.1",
    "string_decoder": "0.10.31"
  },
  "_requested": {
    "raw": "pg-native@*",
    "scope": null,
    "escapedName": "pg-native",
    "name": "pg-native",
    "rawSpec": "*",
    "spec": "*",
    "type": "range"
  },
  "_requiredBy": [
    "/"
  ],
  "_resolved": "https://registry.npmjs.org/pg-native/-/pg-native-1.10.1.tgz",
  "_shasum": "94e61ccbb85a7f3436b2e526315c7581107fe40c",
  "_shrinkwrap": null,
  "_spec": "pg-native@*",
  "_where": "/Users/cameronmclachlan/WebstormProjects/OtherKPS/PostalSystem",
  "author": {
    "name": "Brian M. Carlson"
  },
  "bugs": {
    "url": "https://github.com/brianc/node-pg-native/issues"
  },
  "dependencies": {
    "libpq": "^1.7.0",
    "pg-types": "1.6.0",
    "readable-stream": "1.0.31"
  },
  "description": "A slightly nicer interface to Postgres over node-libpq",
  "devDependencies": {
    "async": "^0.9.0",
    "concat-stream": "^1.4.6",
    "generic-pool": "^2.1.1",
    "lodash": "^2.4.1",
    "mocha": "^1.21.4",
    "okay": "^0.3.0",
    "pg": "*",
    "semver": "^4.1.0"
  },
  "directories": {},
  "dist": {
    "shasum": "94e61ccbb85a7f3436b2e526315c7581107fe40c",
    "tarball": "https://registry.npmjs.org/pg-native/-/pg-native-1.10.1.tgz"
  },
  "gitHead": "e45f2d18a64ac61d61166a21f1b3a81639e88d2c",
  "homepage": "https://github.com/brianc/node-pg-native",
  "keywords": [
    "postgres",
    "pg",
    "libpq"
  ],
  "license": "MIT",
  "main": "index.js",
  "maintainers": [
    {
      "name": "brianc",
      "email": "brian.m.carlson@gmail.com"
    }
  ],
  "name": "pg-native",
  "optionalDependencies": {},
  "readme": "#node-pg-native\n\n[![Build Status](https://travis-ci.org/brianc/node-pg-native.svg?branch=master)](https://travis-ci.org/brianc/node-pg-native)\n\nHigh performance native bindings between node.js and PostgreSQL via [libpq](https://github.com/brianc/node-libpq) with a simple API.\n\n## install\n\nYou need PostgreSQL client libraries & tools installed. An easy way to check is to type `pg_config`. If `pg_config` is in your path, you should be good to go. If it's not in your path you'll need to consult operating specific instructions on how to go about getting it there.\n\nSome ways I've done it in the past:\n\n- On OS X: `brew install postgres`\n- On Ubuntu/Debian: `apt-get install libpq-dev g++ make`\n- On RHEL/CentOS: `yum install postgresql-devel`\n- On Windows:\n 1. Install Visual Studio C++ (successfully built with Express 2010). Express is free.\n 2. Install PostgreSQL (`http://www.postgresql.org/download/windows/`)\n 3. Add your Postgre Installation's `bin` folder to the system path (i.e. `C:\\Program Files\\PostgreSQL\\9.3\\bin`).\n 4. Make sure that both `libpq.dll` and `pg_config.exe` are in that folder.\n\nAfterwards `pg_config` should be in your path. Then...\n\n```sh\n$ npm i pg-native\n```\n\n## use\n\n### async\n\n```js\nvar Client = require('pg-native')\n\nvar client = new Client();\nclient.connect(function(err) {\n  if(err) throw err\n\n  //text queries\n  client.query('SELECT NOW() AS the_date', function(err, rows) {\n    if(err) throw err\n\n    console.log(rows[0].the_date) //Tue Sep 16 2014 23:42:39 GMT-0400 (EDT)\n\n    //parameterized statements\n    client.query('SELECT $1::text as twitter_handle', ['@briancarlson'], function(err, rows) {\n      if(err) throw err\n\n      console.log(rows[0].twitter_handle) //@briancarlson\n    })\n\n    //prepared statements\n    client.prepare('get_twitter', 'SELECT $1::text as twitter_handle', 1, function(err) {\n      if(err) throw err\n\n      //execute the prepared, named statement\n      client.execute('get_twitter', ['@briancarlson'], function(err, rows) {\n        if(err) throw err\n\n        console.log(rows[0].twitter_handle) //@briancarlson\n\n        //execute the prepared, named statement again\n        client.execute('get_twitter', ['@realcarrotfacts'], function(err, rows) {\n          if(err) throw err\n\n          console.log(rows[0].twitter_handle) //@realcarrotfacts\n          \n          client.end(function() {\n            console.log('ended')\n          })\n        })\n      })\n    })\n  })\n})\n\n```\n\n### sync\n\nBecause `pg-native` is bound to [libpq](https://github.com/brianc/node-libpq) it is able to provide _sync_ operations for both connecting and queries. This is a bad idea in _non-blocking systems_ like web servers, but is exteremly convienent in scripts and bootstrapping applications - much the same way `fs.readFileSync` comes in handy.\n\n```js\nvar Client = require('pg-native')\n\nvar client = new Client()\nclient.connectSync()\n\n//text queries\nvar rows = client.querySync('SELECT NOW() AS the_date')\nconsole.log(rows[0].the_date) //Tue Sep 16 2014 23:42:39 GMT-0400 (EDT)\n\n//parameterized queries\nvar rows = client.querySync('SELECT $1::text as twitter_handle', ['@briancarlson'])\nconsole.log(rows[0].twitter_handle) //@briancarlson\n\n//prepared statements\nclient.prepareSync('get_twitter', 'SELECT $1::text as twitter_handle', 1)\n\nvar rows = client.executeSync('get_twitter', ['@briancarlson'])\nconsole.log(rows[0].twitter_handle) //@briancarlson\n\nvar rows = client.executeSync('get_twitter', ['@realcarrotfacts'])\nconsole.log(rows[0].twitter_handle) //@realcarrotfacts\n```\n\n## api\n\n### constructor\n\n- __`constructor Client()`__\n\nConstructs and returns a new `Client` instance\n\n### async functions\n\n- __`client.connect(<params:string>, callback:function(err:Error))`__\n\nConnect to a PostgreSQL backend server. \n\n__params__ is _optional_ and is in any format accepted by [libpq](http://www.postgresql.org/docs/9.3/static/libpq-connect.html#LIBPQ-CONNSTRING).  The connection string is passed _as is_ to libpq, so any format supported by libpq will be supported here.  Likewise, any format _unsupported_ by libpq will not work.  If no parameters are supplied libpq will use [environment variables](http://www.postgresql.org/docs/9.3/static/libpq-envars.html) to connect.\n\nReturns an `Error` to the `callback` if the connection was unsuccessful.  `callback` is _required_.\n\n##### example\n\n```js\nvar client = new Client()\nclient.connect(function(err) {\n  if(err) throw err\n  \n  console.log('connected!')\n})\n\nvar client2 = new Client()\nclient2.connect('postgresql://user:password@host:5432/database?param=value', function(err) {\n  if(err) throw err\n  \n  console.log('connected with connection string!')\n})\n```\n\n- __`client.query(queryText:string, <values:string[]>, callback:Function(err:Error, rows:Object[]))`__\n\nExecute a query with the text of `queryText` and _optional_ parameters specified in the `values` array. All values are passed to the PostgreSQL backend server and executed as a parameterized statement.  The callback is _required_ and is called with an `Error` object in the event of a query error, otherwise it is passed an array of result objects.  Each element in this array is a dictionary of results with keys for column names and their values as the values for those columns.\n\n##### example\n\n```js\nvar client = new Client()\nclient.connect(function(err) {\n  if (err) throw err\n  \n  client.query('SELECT NOW()', function(err, rows) {\n    if (err) throw err\n    \n    console.log(rows) // [{ \"now\": \"Tue Sep 16 2014 23:42:39 GMT-0400 (EDT)\" }]\n    \n    client.query('SELECT $1::text as name', ['Brian'], function(err, rows) {\n      if (err) throw err\n      \n      console.log(rows) // [{ \"name\": \"Brian\" }]\n      \n      client.end()\n    })\n  })\n})\n```\n\n\n- __`client.prepare(statementName:string, queryText:string, nParams:int, callback:Function(err:Error))`__\n\nPrepares a _named statement_ for later execution.  You _must_ supply the name of the statement via `statementName`, the command to prepare via `queryText` and the number of parameters in `queryText` via `nParams`. Calls the callback with an `Error` if there was an error.\n\n##### example\n\n```js\nvar client = new Client()\nclient.connect(function(err) {\n  if(err) throw err\n  \n  client.prepare('prepared_statement', 'SELECT $1::text as name', 1, function(err) {\n    if(err) throw err\n    \n    console.log('statement prepared')\n    client.end()\n  })\n  \n})\n```\n\n- __`client.execute(statementName:string, <values:string[]>, callback:Function(err:err, rows:Object[]))`__\n\nExecutes a previously prepared statement on this client with the name of `statementName`, passing it the optional array of query parameters as a `values` array.  The `callback` is mandatory and is called with and `Error` if the execution failed, or with the same array of results as would be passed to the callback of a `client.query` result.\n\n##### example\n\n\n```js\nvar client = new Client()\nclient.connect(function(err) {\n  if(err) throw err\n  \n  client.prepare('i_like_beans', 'SELECT $1::text as beans', 1, function(err) {\n    if(err) throw err\n    \n    client.execute('i_like_beans', ['Brak'], function(err, rows) {\n      if(err) throw err\n      \n      console.log(rows) // [{ \"i_like_beans\": \"Brak\" }]\n      client.end()\n    })\n  })\n})\n```\n\n- __`client.end(<callback:Function()>`__\n\nEnds the connection. Calls the _optional_ callback when the connection is terminated.\n\n##### example\n\n```js\nvar client = new Client()\nclient.connect(function(err) {\n  if(err) throw err\n  client.end(function() {\n    console.log('client ended') // client ended\n  })\n})\n```\n\n- __`client.cancel(callback:function(err))`__\n\nCancels the active query on the client. Callback receives an error if there was an error _sending_ the cancel request.\n\n##### example\n```js\nvar client = new Client()\nclient.connectSync()\n//sleep for 100 seconds\nclient.query('select pg_sleep(100)', function(err) {\n  console.log(err) // [Error: ERROR: canceling statement due to user request]\n})\nclient.cancel(function(err) {\n  console.log('cancel dispatched')\n})\n\n```\n\n### sync functions\n\n- __`client.connectSync(params:string)`__\n\nConnect to a PostgreSQL backend server. Params is in any format accepted by [libpq](http://www.postgresql.org/docs/9.3/static/libpq-connect.html#LIBPQ-CONNSTRING).  Throws an `Error` if the connection was unsuccessful.\n\n- __`client.querySync(queryText:string, <values:string[]>) -> results:Object[]`__\n\nExecutes a query with a text of `queryText` and optional parameters as `values`. Uses a parameterized query if `values` are supplied.  Throws an `Error` if the query fails, otherwise returns an array of results.\n\n- __`client.prepareSync(statementName:string, queryText:string, nParams:int)`__\n\nPrepares a name statement with name of `statementName` and a query text of `queryText`. You must specify the number of params in the query with the `nParams` argument.  Throws an `Error` if the statement is un-preparable, otherwise returns an array of results.\n\n- __`client.executeSync(statementName:string, <values:string[]>) -> results:Object[]`__\n\nExecutes a previously prepared statement on this client with the name of `statementName`, passing it the optional array of query paramters as a `values` array.  Throws an `Error` if the execution fails, otherwas returns an array of results.\n\n## testing\n\n```sh\n$ npm test\n```\n\nTo run the tests you need a PostgreSQL backend reachable by typing `psql` with no connection parameters in your terminal. The tests use [environment variables](http://www.postgresql.org/docs/9.3/static/libpq-envars.html) to connect to the backend. \n\nAn example of supplying a specific host the tests:\n\n```sh\n$ PGHOST=blabla.mydatabasehost.com npm test\n```\n\n\n## license\n\nThe MIT License (MIT)\n\nCopyright (c) 2014 Brian M. Carlson\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n",
  "readmeFilename": "README.md",
  "repository": {
    "type": "git",
    "url": "git://github.com/brianc/node-pg-native.git"
  },
  "scripts": {
    "test": "mocha"
  },
  "version": "1.10.1"
}
